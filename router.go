// Code generated by hertz generator.

package main

import (
	"context"

	//"fmt"
	"log"
	"net/http"

	"github.com/cloudwego/hertz/pkg/app"
	//"github.com/cloudwego/hertz/pkg/app/client/loadbalance"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/kitex/pkg/generic"

	handler "github.com/yiwen101/CardWizards/biz/handler"
	service "github.com/yiwen101/CardWizards/service"
	temp "github.com/yiwen101/CardWizards/temp"
)

// todo: if error occur in the gateway, return error message properly

// customizeRegister registers customize routers.
func customizedRegister(r *server.Hertz) {
	// todo: write documentation, differentiate build time and run time;
	// todo: for other methods? post, head etcs
	// question: how to check parameters are valid?
	//question: how to check the service name and method name are valid?
	r.GET("/ping", handler.Ping)

	generateRoutes()

	for _, route := range routes {
		switch route.httpMethod {
		case http.MethodGet:
			r.GET(route.route, route.handler)
			continue
		case http.MethodPost:
			r.POST(route.route, route.handler)
			continue
		case http.MethodPut:
			r.PUT(route.route, route.handler)
			continue
		case http.MethodDelete:
			r.DELETE(route.route, route.handler)
			continue
		case http.MethodPatch:
			r.PATCH(route.route, route.handler)
			continue
		case http.MethodHead:
			r.HEAD(route.route, route.handler)
			continue
		case http.MethodOptions:
			r.OPTIONS(route.route, route.handler)
			continue
		default:
			log.Println(" unsupported http method, invalid route ")
			continue
		}
	}
}

func genericHandlerFor(method string) func(ctx context.Context, c *app.RequestContext) {
	return func(ctx context.Context, c *app.RequestContext) {

		serviceName := c.Param("serviceName")
		methodName := c.Param("methodName")
		// toOptimise: if serviceName is not in the map, return a http response with error message
		if !service.HasService(serviceName) {
			c.JSON(http.StatusNotFound, "service not found")
			return
		} else {

			//todo: if methodName is not in the map, return a http response with error message
			cli, err := service.GetClient(serviceName)
			if err != nil {
				log.Println("error in getting client")
				panic(err)
			}

			// Todo: find a mean to bind and validate the parameters
			//string(c.Request.URI().Path()) == /gateway/arith/add. get function lookup failed; +c.URI().QueryArgs().String()
			log.Println("http request url is: " + c.Request.URI().String())

			// call
			genericResponse, err := cli.GenericCall(ctx, methodName, service.BuildRequest(c, method))
			if err != nil {
				log.Println("error in generic call")
				panic(err)
			}

			resp := genericResponse.(*generic.HTTPResponse)
			// return response
			c.JSON(int(resp.StatusCode), resp.Body)
		}
	}
}

type route struct {
	httpMethod string
	route      string
	handler    func(ctx context.Context, c *app.RequestContext)
}

var routes []route

func generateRoutes() {
	routes = []route{}
	var genericRoute = route{
		httpMethod: temp.RefaultHttpMethod,
		route:      temp.RefaultRoute,
		handler:    genericHandlerFor(http.MethodPost),
	}
	routes = append(routes, genericRoute)
	// complex feature: use the annotation of the thrift file
	// intermediate feature: give route at command line
}

func handlerFor() func(ctx context.Context, c *app.RequestContext) {
	// todo
	return func(ctx context.Context, c *app.RequestContext) {}
}

/*map[string]interface{}:
//  4: optional map<i64, ReqItem> req_items (api.body='req_items')
// need parse string into int64
switch tt {
case descriptor.STRUCT:
	return descriptor.STRUCT, writeStruct, nil
case descriptor.MAP:
	return descriptor.MAP, writeStringMap, nil
}
*/
