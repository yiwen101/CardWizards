// Code generated by hertz generator.

package main

import (
	"context"
	"log"
	"net/http"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/yiwen101/CardWizards/common"
	"github.com/yiwen101/CardWizards/common/descriptor"
	"github.com/yiwen101/CardWizards/router"
	"github.com/yiwen101/CardWizards/service"
	clients "github.com/yiwen101/CardWizards/service/clients"
)

// interface; bindValidator/clients to handler; abstraction; object oriented; single duty, unit testing, configuration, singleManager, singleDatabase, use of ok, err and fatal, common.http as const; // complex feature: use the annotation of the thrift file
// intermediate feature: give route at command line; avoid regenerate twice;

func main() {
	// todo, set up logs and tracer?
	// check proposal, feedbasktemplate, milestone2 sample and software engineering/design pattern books
	// add two listeners and produce string information
	descriptor.BuildDescriptorManager("./IDL")
	clients.BuildGenericClients("./IDL")

	h := server.Default(
		server.WithHostPorts("127.0.0.1:8080"),
	)

	Register(h)
	h.Spin()
}

type toRegist struct {
	httpMethod string
	path       string
	handler    func(ctx context.Context, c *app.RequestContext)
}

func generateToRegists() {
	if tRs != nil {
		return
	}
	tRs = append(generateRegularToRegists(), generateGenericToRegists()...)
}

func generateGenericToRegists() []toRegist {
	hm, err := service.GetHandlerManager()
	if err != nil {
		hlog.Fatal("Internal Server Error in getting the handler manager: ", err)
	}

	ls := make([]toRegist, 7)

	// how to write this as const? since arrays are not constants

	for i, method := range common.HTTPMethods() {
		handlerFunc := hm.HandlerForAnnotatedRoutes(method)
		tR := toRegist{
			httpMethod: method,
			path:       common.GenericPath2,
			handler:    handlerFunc,
		}
		ls[i] = tR
	}
	return ls
	// todo
	// complex feature: use the annotation of the thrift file
	// intermediate feature: give route at command line
}

func generateRegularToRegists() []toRegist {
	hm, err := service.GetHandlerManager()
	if err != nil {
		hlog.Fatal("Internal Server Error in getting the handler manager: ", err)
	}

	rm, err := router.GetRouteManager()
	if err != nil {
		hlog.Fatal("Internal Server Error in getting the route manager: ", err)
	}

	routes, err := rm.GetRoutes()
	if err != nil {
		hlog.Fatal("Internal Server Error in getting the routes: ", err)
	}

	ls := make([]toRegist, len(routes))

	for i, route := range routes {
		http, path := route.GetRoute()
		toRegist := toRegist{
			httpMethod: http,
			path:       path,
			handler:    hm.HandlerForRoute(route.ServiceName, route.MethodName),
		}
		ls[i] = toRegist
	}
	return ls
}

var tRs []toRegist

func Register(r *server.Hertz) {
	generateToRegists()

	for _, tR := range tRs {
		switch tR.httpMethod {
		case http.MethodGet:
			r.GET(tR.path, tR.handler)
			continue
		case http.MethodPost:
			r.POST(tR.path, tR.handler)
			continue
		case http.MethodPut:
			r.PUT(tR.path, tR.handler)
			continue
		case http.MethodDelete:
			r.DELETE(tR.path, tR.handler)
			continue
		case http.MethodPatch:
			r.PATCH(tR.path, tR.handler)
			continue
		case http.MethodHead:
			r.HEAD(tR.path, tR.handler)
			continue
		case http.MethodOptions:
			r.OPTIONS(tR.path, tR.handler)
			continue
		default:
			log.Println(" unsupported http method, invalid route ")
			continue
		}
	}
	log.Println("routes and handlers registered to the server")
}
